<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Kubernetes自定义调度器</title>
    <link href="/2024/06/23/Kubernetes%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B0%83%E5%BA%A6%E5%99%A8/"/>
    <url>/2024/06/23/Kubernetes%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B0%83%E5%BA%A6%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<ul><li>Metadata<ul><li>Link: <a href="Project__k8s%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B0%83%E5%BA%A6%E5%99%A8.md">Project__k8s 自定义调度器</a></li><li>Date: [[2022-10-26_周三]]</li><li>Tag:  #云原生&#x2F;kubernetes</li><li>Index: <a href="Kubernetes%E4%BA%91%E5%8E%9F%E7%94%9F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md">Kubernetes 云原生操作系统</a></li><li>Repo: <a href="https://github.com/potapotato/my-scheduler">potapotato&#x2F;my-scheduler: k8s custom scheduler (github.com)</a></li></ul></li></ul><hr><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>其实想自定义调度器是一件非常简单的事情，可无奈的是很难检索到相关博客或者资料，经过苦心寻找最终还是在 <a href="https://banzaicloud.com/blog/k8s-custom-scheduler/">这篇博客</a> 上找到了答案。想要自定义调度器，必须先要理解和会用 <a href="Client-go.md">Client-go</a> ，想要和 <a href="Kubernetes%E4%BA%91%E5%8E%9F%E7%94%9F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md">Kubernetes</a> 的 APIServer 交互这是必不可少的</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>既然要自定义调度器，那就要知道调度器的输入和输出是什么，其实很简单。</p><ul><li>输入：未调度的 Pod</li><li>输出：给未调度的 Pod 的 <code>Spec.NodeName</code> 字段赋值，并发送给 APIServer</li></ul><blockquote><p>由于 k8s 优秀的设计，使得各个组件直接相互解耦，只需通过 APIServer 来通信。调度器只需要告诉 APIServer 该 Pod 要调度到那里，具体调度是由 Kubelet 负责的。</p></blockquote><p>为此，就需要拿到未调度的 Pod，想拿到未调度的 Pod 有两种方式：</p><ol><li>通过 <a href="Client-go.md#3.%20Clients%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AF%B9%E8%B1%A1">Clients 客户端对象</a> 去 <code>Watch</code> APIServer 中的 Pod 资源，一旦发生 <code>ADDED</code> 事件，则说明有新的Pod加入，此时去处理即可。</li><li>通过 [[Client-go#4. Informer]] 作为缓存，然后同样监听 Informer 中提供的 PodInformer 的 <code>ADDED</code> 事件即可。<blockquote><p>两者本质是一样的，但是更推荐使用 Informer，降低 APIServer 的压力</p></blockquote></li></ol><p>拿到了未调度的 Pod 后，还需要执行以下操作：</p><ul><li>查看一下 <code>Spec.ScheduleName</code> 是不是当前写的调度器的名字，如果是则运行自己的调度逻辑，找出合适的<code>node</code>并给 <code>Spec.NodeName</code> 赋值</li><li>将选择的节点和待调度的 pod 进行 bind 操作</li><li>手动发送一个 <code>Scheduled</code> 事件以便进行监控</li></ul><h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><blockquote><p>为了简单起见，只写一个简单的随机调度器，主要是为了研究如何从零写一个调度器</p></blockquote><p>源码解析：</p><ol><li><p>创建clientset，也即创建一个和 <code>APIServer</code> 沟通的客户端</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">    <span class="hljs-comment">// 创建配置</span><br>    config, err := clientcmd.BuildConfigFromFlags(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;config&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err.Error())<br>    &#125;<br><br>    <span class="hljs-comment">// 创建 clientset</span><br>    clientset, err := kubernetes.NewForConfig(config)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err.Error())<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>使用 <code>watch</code> 进行监听<br>有了客户端后，接下来要做的就是通过 <code>watch</code> 建立一个长链接，监听 <code>pod</code> 资源的改变</p><blockquote><p>注意这里指定了一个 FieldSelector ，只监听 schedulerName 等于当前调度器的且未被调取的 pod</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">    watch, err := clientset.CoreV1().Pods(<span class="hljs-string">&quot;&quot;</span>).Watch(context.TODO(), metav1.ListOptions&#123;<br>        FieldSelector: fmt.Sprintf(<span class="hljs-string">&quot;spec.schedulerName=%s,spec.nodeName=&quot;</span>, schedulerName),<br>    &#125;)<br><br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err.Error())<br>    &#125;<br></code></pre></td></tr></table></figure><p>这里获取到的 <code>watch</code> 是一个 <code>chan</code> 对象，只要 <code>pod</code> 资源发生变化，那么变化的事件就会通过该通道传递。因此我们需要去遍历该通道，等待我们期待的 <code>ADDED</code> 事件</p></li><li><p>执行调度算法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(<span class="hljs-string">&quot;start watching ...&quot;</span>)<br>    <span class="hljs-keyword">for</span> event := <span class="hljs-keyword">range</span> watch.ResultChan() &#123;<br><span class="hljs-comment">// 判断事件类型</span><br>        <span class="hljs-keyword">if</span> event.Type != <span class="hljs-string">&quot;ADDED&quot;</span> &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        p := event.Object.(*corev1.Pod)<br>        fmt.Println(<span class="hljs-string">&quot;found a pod to schedule:&quot;</span>, p.Namespace, <span class="hljs-string">&quot;/&quot;</span>, p.Name)<br><br>        <span class="hljs-comment">// 调度</span><br>        scheduledNode, err := ChooseFitNode(clientset)<br>        fmt.Printf(<span class="hljs-string">&quot;schedule the pod to %s\n&quot;</span>, scheduledNode.Name)<br><br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-built_in">panic</span>(err.Error())<br>        &#125;<br></code></pre></td></tr></table></figure><p>当发现 <code>ADDED</code> 事件时，则通过该 <code>pod</code> 去执行调度算法（这里是一个随机选择的算法）</p></li></ol><p>随机选择算法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ChooseFitNode</span><span class="hljs-params">(clientset *kubernetes.Clientset)</span></span> (*corev1.Node, <span class="hljs-type">error</span>) &#123;<br>    nodes, _ := clientset.CoreV1().Nodes().List(context.TODO(), metav1.ListOptions&#123;&#125;)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nodes.Items) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;no nodes can be scheduled&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> &amp;nodes.Items[rand.Intn(<span class="hljs-built_in">len</span>(nodes.Items))], <span class="hljs-literal">nil</span><br><br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li><p>bind操作<br>当找到合适的 <code>node</code> 后，就可以将该 <code>node</code> 和 <code>pod</code> 进行绑定</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// bind 操作</span><br>clientset.CoreV1().Pods(p.Namespace).Bind(context.TODO(), &amp;corev1.Binding&#123;<br>ObjectMeta: metav1.ObjectMeta&#123;<br>Name:      p.Name,<br>Namespace: p.Namespace,<br>&#125;,<br>Target: corev1.ObjectReference&#123;<br>APIVersion: <span class="hljs-string">&quot;v1&quot;</span>,<br>Kind:       <span class="hljs-string">&quot;Node&quot;</span>,<br>Name:       scheduledNode.Name,<br>&#125;,<br>&#125;, metav1.CreateOptions&#123;&#125;)<br></code></pre></td></tr></table></figure></li><li><p>最后发送一个 <code>Scheduled</code> 事件，方便监控</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 发送一个 `Scheduled` 事件，以便监控</span><br>timestamp := time.Now().UTC()<br>message := fmt.Sprintf(<span class="hljs-string">&quot;schedule pod %s/%s to node %s\n&quot;</span>, p.Namespace, p.Name, scheduledNode.Name)<br>clientset.CoreV1().Events(p.Namespace).Create(context.TODO(), &amp;corev1.Event&#123;<br>Count:          <span class="hljs-number">1</span>,<br>Message:        message,<br>Reason:         <span class="hljs-string">&quot;Scheduled&quot;</span>,<br>LastTimestamp:  metav1.NewTime(timestamp),<br>FirstTimestamp: metav1.NewTime(timestamp),<br>Type:           <span class="hljs-string">&quot;Normal&quot;</span>,<br>Source: v1.EventSource&#123;<br>Component: schedulerName,<br>&#125;,<br>InvolvedObject: v1.ObjectReference&#123;<br>Kind:      <span class="hljs-string">&quot;Pod&quot;</span>,<br>Name:      p.Name,<br>Namespace: p.Namespace,<br>UID:       p.UID,<br>&#125;,<br>ObjectMeta: metav1.ObjectMeta&#123;<br>GenerateName: p.Name + <span class="hljs-string">&quot;-&quot;</span>,<br>&#125;,<br>&#125;, metav1.CreateOptions&#123;&#125;)<br></code></pre></td></tr></table></figure></li><li><p>编写一个 pod 并指定 <code>Spec.scheduleName</code>为当前调度器名字<br>运行结果：</p><img src="/2024/06/23/Kubernetes%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B0%83%E5%BA%A6%E5%99%A8/Pastedimage20240623103657.png" class=""></li></ol><h2 id="Informer-版实现"><a href="#Informer-版实现" class="headerlink" title="Informer 版实现"></a>Informer 版实现</h2><p>虽然只是将 <code>watch</code> 修改为了 <code>Informer</code> 进行缓存，但整体实现起来还是有在较大差别</p><p>首先是 <code>Scheduler</code> 的定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Schedule <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 调度器名字</span><br>scheduleName    <span class="hljs-type">string</span><br><span class="hljs-comment">// 和apiserver交互的客户端</span><br>client          *kubernetes.Clientset<br><span class="hljs-comment">// informer的工厂</span><br>informerFactory informers.SharedInformerFactory<br><span class="hljs-comment">// 工作队列</span><br>queue           <span class="hljs-keyword">chan</span> *v1.Pod<br>&#125;<br></code></pre></td></tr></table></figure><p>具体原理是：</p><ul><li>从 <code>informerFactory</code> 中获取 <code>informer</code> 对象，并绑定对应资源的监听事件，当发生 <code>ADDED</code> 时，将对应的 <code>pod</code> 送入工作队列中</li><li>启动所有 <code>informer</code> ，并死循环执行调度函数</li><li>调度函数负责从工作队列从获取 <code>pod</code> 并进行后续的调度和<code>bind</code>，发送事件等操作</li></ul><p>具体源码见 <a href="https://github.com/potapotato/my-scheduler">potapotato&#x2F;my-scheduler: k8s custom scheduler (github.com)</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ThreadLocal</title>
    <link href="/2024/06/23/ThreadLocal/"/>
    <url>/2024/06/23/ThreadLocal/</url>
    
    <content type="html"><![CDATA[<h2 id="ThreadLocal-概述"><a href="#ThreadLocal-概述" class="headerlink" title="ThreadLocal 概述"></a>ThreadLocal 概述</h2><blockquote><p>什么是 ThreadLocal，用于解决什么问题？用在什么场景合适？</p></blockquote><p>先来看看官方文档的描述：</p><blockquote><p>[!quote]<br>This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its {@code get} or {@code set} method) has its own, independently initialized copy of the variable. {@code ThreadLocal} instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID)</p></blockquote><p>该类提供了 <strong>线程局部变量</strong>，这些变量和普通变量不一样，当每个线程访问自己的这个变量的时候，访问到的都是独属于自己的变量，它独立于变量的初始化副本。ThreadLocal 实例通常是类中的 private static 字段，它们希望将状态与某一个线程(例如，用户 ID 或事务 ID)相关联。</p><p>按我自己的话说：</p><blockquote><p>[!note]<br>ThreadLocal 是一个将在多线程中为每一个线程创建单独的变量副本的类，每个线程在访问它的时候，访问到的都是自己的那一份副本，把他设置成 private static 的话，在当前线程内就都能访问到，可以用来存储和当前线程相关的一些状态，并且避免多线程因为操作共享变量导致的数据不一致</p></blockquote><p>解决线程安全的思路：</p><ul><li>互斥同步：<a href="Synchronized.md">Synchronized</a> 和 <a href="ReentrantLock.md">ReentrantLock</a></li><li>非阻塞同步：CAS，原子变量</li><li>无同步方案：<a href="ThreadLocal.md">ThreadLocal</a> ，可重入代码</li></ul><p>因此，ThreadLocal 很适合用于保证线程安全，或者存储一些和线程绑定的数据。</p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>提到 ThreadLocal 被提到应用最多的是 session 管理和数据库链接管理，这里以数据库连接访问为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.DriverManager;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectionManager</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Connection&gt; dbConnectionLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;Connection&gt;() &#123;<br><span class="hljs-meta">@Override</span> <span class="hljs-keyword">protected</span> Connection <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;<br> <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">return</span> DriverManager.getConnection(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br> &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>e.printStackTrace();<br> &#125;<br> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br> &#125;<br>&#125;;<br><br><span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> dbConnectionLocal.get(); &#125; &#125;<br><br></code></pre></td></tr></table></figure><p>这样每个线程调用 <code>ConnectionManager</code> 的 <code>getConnection</code> 的时候，拿到的都是属于自己的连接，如果不用 ThreadLocal 的话，那么就可能导致同一个连接被多个线程使用，造成各种问题。</p><blockquote><p>不过一般用连接池管理，而不是 ThreadLocal</p></blockquote><h2 id="ThreadLocal-原理"><a href="#ThreadLocal-原理" class="headerlink" title="ThreadLocal 原理"></a>ThreadLocal 原理</h2><h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><p>在 <strong>Thread</strong> 类中，有这么一个字段 <code>threadLocals</code></p><p>用来存储所有 ThreadLocal 变量，以 Map 的形式，Key 是 ThreadLocal 变量的 HashCode，Value 就是 ThreadLocal 存储的内容。</p><p>但这个 Map 结构有些不一样：</p><ul><li>它没有实现 Map 接口;</li><li>它没有 public 的方法, 最多有一个 default 的构造方法, 因为这个 ThreadLocalMap 的方法仅仅在 ThreadLocal 类中调用, 属于静态内部类</li><li><code>ThreadLocalMap</code> 的 Entry 实现继承了<code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code></li><li>该方法仅仅用了一个 Entry 数组来存储 Key, Value; Entry 并不是链表形式, 而是每个 bucket 里面仅仅放一个 Entry;</li></ul><h4 id="ThreadLocal-set"><a href="#ThreadLocal-set" class="headerlink" title="ThreadLocal.set"></a>ThreadLocal.set</h4><p>该方法的步骤：</p><ol><li>使用 Key 的 HashCode 对 Entry 数据取余，相当于一个哈希的过程，获取存储的位置</li><li>然后从哈希出的位置开始 <strong>线性探测</strong>，如果找到了那么设置为当前最新的值返回</li><li>在线程探测的过程中，如果发现有的 key 是 null，那么说明这个 ThreadLocal 被清理了，则将该 Entry 设置为当前插入的 Value返回</li><li>直到遇见了空槽也没找到匹配的ThreadLocal对象，那么在此空槽处安排ThreadLocal对象和缓存的value。然后将哈希表扩容，如果没有元素被清理，那么就要检查当前元素数量是否超过了容量阙值(数组大小的三分之二)，以便决定是否扩容</li></ol><h4 id="ThreadLocal-get"><a href="#ThreadLocal-get" class="headerlink" title="ThreadLocal.get"></a>ThreadLocal.get</h4><p>其实很简单，就是去哈希表找，找不到则用线性探测法继续往后找</p><h3 id="get-原理"><a href="#get-原理" class="headerlink" title="get 原理"></a>get 原理</h3><p>当调用 ThreadLocal 变量的 <code>get()</code> 方法的时候：</p><p>会首先获取当前的线程，然后以当前线程为参数，去获取 ThreadLocal 的值</p><p>具体步骤：</p><ol><li>通过当前线程拿到 Thread 类中的 map</li><li>如果 map 不为空，则以 ThreadLocal 变量本身为 Key 获取存储的 Value，并返回</li><li>如果 map 为空，调用 <code>setInitialValue</code> 方法返回</li></ol><p><code>setInitialValue</code> 方法如下：</p><ul><li>首先调用 initialValue 方法, 产生一个 Value 对象</li><li>继续查看当前线程的 threadLocals 是不是空的, 如果 ThreadLocalMap 已被初始化, 那么直接将产生的对象添加到 ThreadLocalMap 中, 如果没有初始化, 则创建并添加对象到其中;</li></ul><blockquote><p>注意：创建 ThreadLocal 的时候是可以重载 <code>initialValue</code> 方法的</p></blockquote><h3 id="set-原理"><a href="#set-原理" class="headerlink" title="set 原理"></a>set 原理</h3><p>当调用 ThreadLocal 的 <code>set(T value)</code> 方法去设置值的时候，也会先去获取当前线程，然后以当前线程为参数来设置 ThreadLocal 的值</p><p>具体步骤：</p><ul><li>根据当前线程获取 map</li><li>如果 map 不为空，则直接以 ThreadLocal 变量为 Key，set 的值为 Value 插入 map</li><li>如果 mpa 为空，则创建 map 同时插入 Key，Value</li></ul><h2 id="ThreadLocal-内存泄漏"><a href="#ThreadLocal-内存泄漏" class="headerlink" title="ThreadLocal 内存泄漏"></a>ThreadLocal 内存泄漏</h2><p>为什么 ThreadLocal 可能会导致内存泄漏呢？看以下场景</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br> <span class="hljs-type">ThreadLocal</span> <span class="hljs-variable">local</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>(); <br> local.set(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>());<br> local = <span class="hljs-literal">null</span>;<br> <span class="hljs-comment">// 手动触发GC，此时ThreadLocal被回收，那么value是否被回收呢？</span><br> System.gc(); <br> <span class="hljs-comment">// GC是异步执行的，主线程Sleep一会，等待对象回收 </span><br> ThreadUtil.sleep(<span class="hljs-number">1000</span>); <br>&#125; <br><br><span class="hljs-comment">// 对象被回收时触发 </span><br><span class="hljs-meta">@Override</span> <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123; <br>System.err.println(<span class="hljs-string">&quot;对象被回收...&quot;</span>); <br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>在这种场景下，当程序运行完成后，由于 ThreadLocal 是局部变量，运行完后，不再持有 ThreadLocal  的强引用，而在 <a href="#ThreadLocalMap">ThreadLocalMap</a> 中的 Entry 里，ThreadLocal 作为 Key 是弱引用，没有其他强引用指向，所以会被 GC 回收掉。但是 Value 被 Entry 强引用，如果当前线程再迟迟不结束的话，这些<code>key</code>为<code>null</code>的<code>Entry</code>的<code>value</code>就会一直存在一条强引用链：<code>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</code>永远无法回收，造成内存泄漏。</p><p>但 <a href="#ThreadLocalMap">ThreadLocalMap</a> 的 <code>get</code> 和 <code>set</code> 方法会清除线程<code>ThreadLocalMap</code>里所有<code>key</code>为<code>null</code>的<code>value</code>，可以作为一层预防措施。</p><p>但是这些被动的预防措施并不能保证不会内存泄漏：</p><ul><li>使用线程池的时候，这个线程执行任务结束，<code>ThreadLocal</code>对象被回收了，线程放回线程池中不销毁，这个线程一直不被使用，导致内存泄漏。</li><li>使用线程池的时候，线程执行任务结束，但是 <code>ThreadLocal</code> 是 <code>private static</code> 的，导致强引用一直存在，虽然这些数据已经不用了，但是还在内存中</li><li>分配使用了<code>ThreadLocal</code>又不再调用<code>get()</code>,<code>set()</code>,<code>remove()</code>方法，那么这个期间就会发生内存泄漏。</li></ul><p><strong><code>ThreadLocal</code>内存泄漏的根源是：由于<code>ThreadLocalMap</code>的生命周期跟<code>Thread</code>一样长，如果没有手动删除对应<code>key</code>就会导致内存泄漏，而不是因为弱引用。</strong></p><p>&#x3D;&#x3D;怎么防止 ThreadLocal 内存泄漏呢？ <strong>使用完后及时 remove</strong>&#x3D;&#x3D;</p><h2 id="ThreadLocal-使用场景"><a href="#ThreadLocal-使用场景" class="headerlink" title="ThreadLocal 使用场景"></a>ThreadLocal 使用场景</h2><ul><li>Web中的 Session 管理</li><li>微服务架构中，跨服务调用时的跟踪ID（如分布式链路追踪中的traceId）可以通过 <code>ThreadLocal</code> 在线程内传递，确保所有日志记录都能包含这一标识，便于后续的日志分析和问题排查。</li><li>当每个线程需要独立拥有一个对象实例（如工具类或资源）以避免状态冲突时，使用 <code>ThreadLocal</code> 可以为每个线程提供独立的实例副本</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://pdai.tech/md/java/thread/java-thread-x-threadlocal.html">Java 并发 - ThreadLocal详解 | Java 全栈知识体系 (pdai.tech)</a></li><li><a href="https://zhuanlan.zhihu.com/p/102571059">ThreadLocal的内存泄露？什么原因？如何避免？ - 知乎 (zhihu.com)</a></li><li><a href="https://juejin.cn/post/7042211997743579144">https://juejin.cn/post/7042211997743579144</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL事务实现原理</title>
    <link href="/2024/06/02/MySQL%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <url>/2024/06/02/MySQL%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>本文主要记录 MySQL 中 ACID 特性的具体实现原理</p><p>ACID 4 个特性中：</p><ul><li><strong>一致性（consistency）是目的；</strong></li><li><strong>原子性（atomicity）、隔离性（isolation）、持久性（durability）是手段</strong>。</li></ul><p>简单来说，ACID的实现原理如下：</p><ul><li><strong>原子性</strong>：通过 <code>undo log</code> 来实现事务中断情况下的回滚，从而实现原子性</li><li><strong>持久性</strong>：通过 <code>redo log</code> 这种预写式日志（Write-Ahead-Log）来保证持久性</li><li><strong>隔离性</strong>：通过 锁机制（表锁，意向锁，行锁）+MVCC （隐藏列，undo log版本链，ReadView）机制实现4种事务隔离级别</li><li><strong>一致性</strong>：数据库层面通过AID和一些约束来保障一致性，但这并不够，还需要应用层的保证</li></ul><h2 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h2><p>事务通常由多个语句组成，原子性保证每个事务都被视为一个单独的<code>单元</code>,要么完全成功，要么完全失败。即一个事务（transaction）中的所有操作，要么全部执行成功，要么全部不执行。</p><p>简单来说：<strong>原子性的结果就是没有中间状态</strong>，如果有中间状态则一致性就不会得到满足。</p><p>有两种情况会导致出现中间态：</p><ul><li>情况一：事务执行过程中可能遇到各种错误，比如服务器本身的错误，操作系统错误，甚至是突然断电导致的错误。</li><li>情况二：程序员可以在事务执行过程中手动输入<code>ROLLBACK</code>语句结束当前的事务的执行。</li></ul><p>但没有中间态是不太可能的，因此MySQL 通过 <code>undo log</code> 这种方式，保证了执行失败或者主动要求下可以进行回滚，<strong>同时通过 <a href="#%E9%9A%94%E7%A6%BB%E6%80%A7%EF%BC%88Isolation%EF%BC%89">隔离性（Isolation）</a>  保证了回滚前的中间状态对其他事务不可见。</strong> 这样就可以造成一个假象，即这个事务，看起来什么都没做，符合原子性的要求。</p><blockquote><p>除非是 <code>read uncommited</code>，那么无法隔离</p></blockquote><p>综合来讲，MySQL原子性的实现原理：</p><ul><li>通过 <code>undolog</code> 在失败时回滚保证在<strong>结果上是原子性的</strong>， 即没有中间状态。</li><li>通过<code>隔离性</code>保证了在<strong>其他并发事务看来是原子性的</strong>，即中间状态对外不可见。</li></ul><h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p><code>undo log</code> 它记录了事务中所有逻辑执行语句对应的反操作。当事务发生回滚的时候，InnoDB 会根据 <code>undo log</code> 的内容做相反的工作。</p><p><code>undo log</code> 分为两类：</p><ul><li><code>Insert undo log</code>：当发生插入的时候，会生成这样的一个 <code>undo log</code>，记录了插入的主键ID，在回滚的时候，只需要根据主键ID删除即可</li><li><code>Update undo log</code>：当发生 <code>update</code> 等修改操作时，会将被修改的字段长度，字段原来的值进行记录，在回滚的时候即可将对应的值重新设置回旧值。当发生 <code>delete</code> 操作时，将被删除行进行记录，回滚时重新写入即可。（所以不会立马真的删除整个行，而是先标记，然后保证没有事务可以访问后再真正删除）</li></ul><blockquote><p>[!note]<br>为什么分两种 undo log?</p><ul><li><code>Insert undo log</code> 是针对插入数据生成的，插入数据仅对当前事务可见，因此只用于当前事务回滚，无需参与 MVCC 机制，因此在事务提交后就可以删除，</li><li><code>Update undo log</code> 是对数据修改产生的，需要留下来形成版本链，提供历史版本数据，支持 MVCC 的快照读功能。有了 <code>undo log</code> 才知道之前版本的数据是怎么样的。</li></ul></blockquote><h2 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h2><p>隔离性，指一个事务内部的操作及使用的数据对正在进行的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。<strong>隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。</strong> <strong>正是它保证了原子操作的过程中，中间状态对其它事务不可见</strong>。</p><p>MySQL主要是通过结合 <strong>锁+MVCC机制</strong> 来实现的隔离性，这里先大概总结一下</p><p>在 MySQL 中实现了SQL标准中定义的四个隔离级别</p><table><thead><tr><th>隔离级别</th><th>可能出现的问题</th><th>MySQL的实现方式</th></tr></thead><tbody><tr><td>读未提交</td><td>脏读、不可重复读、幻读</td><td>读写数据不加任何限制，直接读取最新的真实数据</td></tr><tr><td>读已提交</td><td>不可重复读、幻读</td><td>基于<a href="#MVCC%E5%8E%9F%E7%90%86">MVCC</a>实现，每次读取都生成一个快照(<a href="#ReadView">ReadView</a>)，然后读快照内容</td></tr><tr><td>可重复读</td><td>幻读</td><td>基于MVCC和next-key锁实现，仅在第一次读取生成快照，后面都读取同一快照数据，可以杜绝大部分幻读</td></tr><tr><td>串行化</td><td>无</td><td>基于读写锁实现</td></tr></tbody></table><h3 id="并发执行的问题"><a href="#并发执行的问题" class="headerlink" title="并发执行的问题"></a>并发执行的问题</h3><p>这里我们可以先探讨以下在并发情况下可能发生哪些冲突：</p><ul><li>读-读操作：无冲突</li><li>读-写操作：有冲突</li><li>写-写操作：有冲突</li></ul><p>因此，隔离性主要是为了解决 <strong>读写冲突</strong>、<strong>写写冲突</strong>。</p><ul><li><p>如果只采用锁机制来实现隔离级别<br>那么毫无疑问，读写操作和写写操作都必须上锁来保证隔离性，读取的时候上读锁，写的时候上写锁。</p></li><li><p>如果采用 MVCC 机制和锁机制联合<br>那么<strong>读写操作无需上锁</strong>，只有写写操作上锁，因为 MVCC 机制保证了读取的是数据的快照，而写数据是写最新的数据，所以没有冲突，提高了并发的效率。这也是为什么要使用 MVCC,因为可以提高并发效率，解决来读写冲突需要上锁的问题</p></li></ul><h3 id="MVCC原理"><a href="#MVCC原理" class="headerlink" title="MVCC原理"></a>MVCC原理</h3><p>这里的 MVCC 原理主要是 InnoDB 中实现 MVCC 的原理。</p><h4 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h4><p>对于使用<code>InnoDB</code>存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列</p><ul><li><code>trx_id</code>：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的<code>事务id</code>赋值给<code>trx_id</code>隐藏列。</li><li><code>roll_pointer</code>：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到<code>undo日志</code>中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li></ul><p>每次对记录进行更新，都会将旧值放入一个新的 <a href="#undo%20log">undo log</a> 中，这就算是该记录的一个旧版本，<code>undo log</code>  中也有一个 <code>roll_pointer</code>，用来指向更早的 <code>undo log</code>，所以可以形成一个版本链，版本链的头节点就是当前记录最新值：</p><img src="/2024/06/02/MySQL%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/Pastedimage20240425112745.png" class=""><blockquote><p>参考：<a href="https://relph1119.github.io/mysql-learning-notes/#/mysql/24-%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%E7%9A%84%E5%A4%9A%E5%B9%85%E9%9D%A2%E5%AD%94-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8EMVCC">第24章 一条记录的多幅面孔-事务的隔离级别与MVCC</a></p></blockquote><h4 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h4><p><code>ReadView</code> 意思就是一个读视图，可以理解成一个快照。其作用是告诉事务：<strong>版本链中哪些版本是当前事务可见的</strong>，从而通过这个快照来实现隔离</p><p><code>ReadView</code> 中包含以下4个内容：</p><ul><li><code>m_ids</code>：系统中当前活跃的事务 id 列表</li><li><code>min_trx_id</code>：在生成 <code>ReadView</code>  时，当前系统活跃事务的最小 id</li><li><code>max_trx_id</code>：在生成 <code>ReadView</code> 时，当前系统活跃事务的最大 id+1</li><li><code>creator_trx_id</code>：表示生成当前  <code>ReadView</code> 的事务的id</li></ul><p>那么如何根据 <code>ReadView</code> 中的这些内容判断一个记录的版本能不能被当前事务读取呢？前面<a href="#%E7%89%88%E6%9C%AC%E9%93%BE">版本链</a>中提到每一条记录中都有两个隐藏列，其中一个是 <code>trx_id</code>，也就是最新修改当前记录的事务id，我们是根据这个事务id结合<code>ReadView</code>来判断的：</p><ul><li>如果当前记录的 <code>trx_id=creator_id</code> ，那么代表当前记录是当前事务修改或者创建的，可以读取</li><li>如果当前记录的 <code>trx_id&lt;min_trx_id</code>  ，那么代表该记录是过去就已经提交了的事务修改或创建的，可以读取</li><li>如果当前记录的 <code>min_trx_id&lt;trx_id&lt;max_trx_id</code>  ，那么需要分类讨论<ul><li>如果 <code>trx_id</code> 在 <code>m_ids</code> 中，说明修改或者创建这条记录的事务还没有提交，不能读取</li><li>如果  <code>trx_id</code> 不在 <code>m_ids</code> 中，说明修改或者创建这条记录的事务已经提交来，可以读取</li></ul></li><li>如果当前记录的 <code>trx_id&gt;max_trx_id</code>，说明修改或者创建这条记录的事务来自未来，不可读取</li></ul><p>如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上面的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。</p><hr><p>接下来说说 <code>ReadView</code> 是如何用来实现隔离级别的，<code>ReadView</code> 主要参与 <strong>读已提交和可重复读</strong> 两个隔离级别的实现</p><ul><li><p><strong>读已提交</strong><br>对于读已提交，每次读取都需要读取最新的提交数据，因此其实现方式是，&#x3D;&#x3D;每次读取，都生成一个 <code>ReadView</code>&#x3D;&#x3D;，然后读取内容，这样读写之间也是不需要加锁的，所以可能产生不可重复读的问题。（即读到数据被删除或者修改）</p></li><li><p><strong>可重复读</strong><br>对于可重复读，要求每次读到的数据都是一样的（重复的），因此其实现方式是，&#x3D;&#x3D;第一次读取的时候生成一个 <code>ReadView</code> ，之后的每次读取都使用第一次生成的 <code>ReadView</code>&#x3D;&#x3D;，这样就可以实现可重复读了，并且这种方式还一定程度避免了幻读。（因为读的是快照，未来插入的数据是读不到的）</p></li></ul><h3 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h3><h4 id="共享锁和独占锁"><a href="#共享锁和独占锁" class="headerlink" title="共享锁和独占锁"></a>共享锁和独占锁</h4><p>前面我们提到，MySQL 基于锁和MVCC来实现不同的隔离级别，在加锁的时候，要让读-读操作不冲突，使读-写，写-写操作阻塞，因此引入了共享锁（读锁）和独占锁（写锁）。</p><ul><li><code>共享锁</code>，英文名：<code>Shared Locks</code>，简称<code>S锁</code>。在事务要读取一条记录时，需要先获取该记录的<code>S锁</code>。</li><li><code>独占锁</code>，也常称<code>排他锁</code>，英文名：<code>Exclusive Locks</code>，简称<code>X锁</code>。在事务要改动一条记录时，需要先获取该记录的<code>X锁</code>。</li></ul><h4 id="多粒度锁"><a href="#多粒度锁" class="headerlink" title="多粒度锁"></a>多粒度锁</h4><p>在MySQL中的锁有如下类别：</p><table><thead><tr><th>锁类型</th><th>具体锁名</th></tr></thead><tbody><tr><td>表锁</td><td>共享表锁 S</td></tr><tr><td></td><td>独占表锁 X</td></tr><tr><td></td><td>意向读锁 IS</td></tr><tr><td></td><td>意向写锁 IX</td></tr><tr><td></td><td>自增锁 AUTO-INC Lock</td></tr><tr><td></td><td>元数据锁 Metadata Lock</td></tr><tr><td>行锁</td><td>记录锁 Record Lock</td></tr><tr><td></td><td>间隙锁 Gap Lock</td></tr><tr><td></td><td>临键锁 Next-key Lock</td></tr><tr><td></td><td>隐式锁</td></tr><tr><td></td><td>插入意向锁 Insert Intention Lock</td></tr></tbody></table><h5 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h5><p>表锁顾名思义就是锁住整个表，表锁也分为独占锁和共享锁。以下情况下MySQL会上表锁：</p><ol><li><strong>在不支持表锁的存储引擎，比如 MyISAM 中，所有操作都是表锁</strong></li><li>在 InnoDB 中<ol start="2"><li><strong>显式使用 <code>Lock Table</code> 语句</strong></li><li><strong>全表扫描</strong></li><li><strong>外键约束检查</strong></li></ol></li></ol><h5 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h5><p>意向锁存在的意义是为能否上表锁进行一个快速判断。当要给一个表上读锁的时候，先要判断每一个记录有没有上写锁，如果去遍历太耗费时间，因此，假设要对一个记录行上读锁，会先给表上读意向锁（IS），如果要对记录行上写锁，先给表上（IX），这样便于后面上表锁判断。</p><table><thead><tr><th align="center">兼容性</th><th align="center"><code>X</code></th><th align="center"><code>IX</code></th><th align="center"><code>S</code></th><th align="center"><code>IS</code></th></tr></thead><tbody><tr><td align="center"><code>X</code></td><td align="center">不兼容</td><td align="center">不兼容</td><td align="center">不兼容</td><td align="center">不兼容</td></tr><tr><td align="center"><code>IX</code></td><td align="center">不兼容</td><td align="center">兼容</td><td align="center">不兼容</td><td align="center">兼容</td></tr><tr><td align="center"><code>S</code></td><td align="center">不兼容</td><td align="center">不兼容</td><td align="center">兼容</td><td align="center">兼容</td></tr><tr><td align="center"><code>IS</code></td><td align="center">不兼容</td><td align="center">兼容</td><td align="center">兼容</td><td align="center">兼容</td></tr></tbody></table><h5 id="自增锁"><a href="#自增锁" class="headerlink" title="自增锁"></a>自增锁</h5><p>在使用<code>MySQL</code>过程中，我们可以为表的某个列添加<code>AUTO_INCREMENT</code>属性，之后在插入记录时，可以不指定该列的值，系统会自动为它赋上递增的值。</p><p>这种自增的原理是内存中为每个表维护了一个全局变量，因此当发生并发插入的时候，需要上锁。就是在执行插入语句时就在表级别加一个<code>AUTO-INC</code>锁，然后为每条待插入记录的<code>AUTO_INCREMENT</code>修饰的列分配递增的值，在该语句执行结束后，再把<code>AUTO-INC</code>锁释放掉。这样一个事务在持有<code>AUTO-INC</code>锁的过程中，其他事务的插入语句都要被阻塞，可以保证一个语句中分配的递增值是连续的。</p><h5 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h5><p>元数据锁是一种特殊的表锁，用于保护表的元数据（如表结构）在并发操作下的完整性。当执行涉及表结构变更的语句（如<code>ALTER TABLE</code>、<code>CREATE INDEX</code>、<code>DROP TABLE</code>等）或查询表的元数据信息时，MySQL会自动对表加元数据锁。</p><h5 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h5><blockquote><p>从这里开始就是行锁，行锁是最重要的锁。这里要强调的是，记录锁是针对索引上的锁，因为你要上锁肯定要找到这个记录再上锁吧，怎么找？靠索引，如果没有索引怎么办？那只能全表扫了，那也就升级成表锁了。</p></blockquote><p><strong><code>Record Lock</code> 时最正儿八经的行锁，功能就是锁住对应的行</strong>。记录锁也是分为读锁和写锁的，上写锁的时候其余事务都无法获取任何锁来做操作，上读锁的时候其他事务也可以上读锁。</p><img src="/2024/06/02/MySQL%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/Pastedimage20240425192348.png" class=""><p>以下情况会上记录锁：</p><ul><li>在执行<code>SELECT ... FOR UPDATE</code>、<code>SELECT ... LOCK IN SHARE MODE</code>、<code>UPDATE</code>或<code>DELETE</code>等操作时自动设置，用于保护特定行的并发访问（即执行 <a href="#%E9%94%81%E5%AE%9A%E8%AF%BB%EF%BC%88%E5%BD%93%E5%89%8D%E8%AF%BB%EF%BC%89">锁定读（当前读）</a> 操作时）</li></ul><h5 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h5><p><code>Gap Lock</code> 是为了解决幻读出现的锁，目的是锁住记录之间的间隙，不包括记录本身，也就是一个开区间。</p><blockquote><p>[!danger] 为什么要间隙锁？<br>当我们采用范围扫描来查询数据的时候，如果采用行锁，那么确实可以锁住记录不让其他事务修改，但是防不住其他事务在我们的记录间隙中进行插入，比如我们查询 <code>where id between 3 and 8</code>，记录锁只能锁 3 和 8，但是如果其他事务插入一个 5，那么我们还是可以读到。（可能有人觉得 MVCC 不是快照读，只要我们刚开始的时候没有其他事务插入不就读不到了吗？没错，如果是 <a href="#%E4%B8%80%E8%87%B4%E6%80%A7%E8%AF%BB%EF%BC%88%E5%BF%AB%E7%85%A7%E8%AF%BB%EF%BC%89">一致性读（快照读）</a> 确实不用担心这个问题，但是如果我们是 <a href="#%E9%94%81%E5%AE%9A%E8%AF%BB%EF%BC%88%E5%BD%93%E5%89%8D%E8%AF%BB%EF%BC%89">锁定读（当前读）</a> ，即通过加锁的方式，读取最新内容，普通的记录锁就无法保证不产生幻读，即有新的记录插入了）MySQL 的设计者们因此想出了间隙锁，把（3，8）这个区间锁住，想插入的时候就会被这个锁拦住。在MySQL的可重复读（Repeatable Read）隔离级别下，InnoDB默认启用间隙锁。</p></blockquote><p>例如下图：给值为8的记录上锁的时候，会将 （3，8）这个间隙上锁，即给前面的间隙上锁。</p><img src="/2024/06/02/MySQL%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/Pastedimage20240425192402.png" class=""><blockquote><p>还有一点要注意的是，<strong>间隙锁是不互斥的，因此两个事务都上间隙锁，然后插入，可能导致死锁</strong></p></blockquote><h5 id="临键锁"><a href="#临键锁" class="headerlink" title="临键锁"></a>临键锁</h5><p>有时候我们既想锁住某条记录，又想阻止其他事务在该记录前面的<code>间隙</code>插入新记录，所以设就有了一种称之为<code>Next-Key Locks</code>的锁，官方的类型名称为：<code>LOCK_ORDINARY</code>，我们也可以简称为<code>next-key锁</code>，本质是 <a href="#%E8%AE%B0%E5%BD%95%E9%94%81">记录锁</a> 和 <a href="#%E9%97%B4%E9%9A%99%E9%94%81">间隙锁</a> 的结合，上锁的区间是 <strong>前开后闭</strong></p><p>临键锁实际上是 InnoDB 在 RR 隔离级别下默认使用的行锁类型，用来完全避免幻读。当对一个索引范围进行查询或更新时，InnoDB不仅锁定查询条件直接命中的记录，还会锁定查询条件两侧的间隙，确保在事务执行期间，其他事务不能在这个范围内插入新的记录。</p><p>下图，是给 8 这个行上记录锁，给前面的间隙上间隙锁</p><img src="/2024/06/02/MySQL%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/Pastedimage20240425193324.png" class=""><p>什么时候上间隙锁？</p><ol><li><strong>默认行为（RR隔离级别）</strong>：<ul><li>在可重复读（RR）隔离级别下，InnoDB对索引记录的锁定是默认采用临键锁。这意味着，除了锁定特定的索引记录外，还会自动锁定该记录前面的间隙。</li><li>示例：<code>SELECT * FROM table WHERE id = 10 FOR UPDATE;</code> 不仅会对id为10的记录加记录锁，还会对该记录之前（小于10）的间隙加锁。</li></ul></li><li><strong>范围查询</strong>：<ul><li>对于涉及范围的查询（如使用<code>BETWEEN</code>、<code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>等操作符），InnoDB不仅会对查询条件命中的每个索引记录加记录锁，还会对这些记录两侧的间隙分别加间隙锁。因此，范围查询实际上会施加一系列临键锁。</li><li>示例：<code>SELECT * FROM table WHERE id BETWEEN 10 AND 20 FOR UPDATE;</code> 会对id为10到20之间的每个记录以及这些记录之间的间隙都加临键锁。</li></ul></li></ol><h5 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h5><p>一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了所谓的 <a href="#%E9%97%B4%E9%9A%99%E9%94%81">间隙锁</a>，如果有的话，插入操作需要等待，直到拥有<a href="#%E9%97%B4%E9%9A%99%E9%94%81">间隙锁</a>的那个事务提交。但是设计<code>InnoDB</code>的大佬规定事务在等待的时候也需要在内存中生成一个<code>锁结构</code>，表明有事务想在某个<code>间隙</code>中插入新记录，但是现在在等待。设计<code>InnoDB</code>的大佬就把这种类型的锁命名为<code>Insert Intention Locks</code>，官方的类型名称为：<code>LOCK_INSERT_INTENTION</code>，我们也可以称为<code>插入意向锁</code>。但<strong>事实上插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁</strong>（<code>插入意向锁</code>就是这么鸡肋）。</p><h5 id="隐式锁"><a href="#隐式锁" class="headerlink" title="隐式锁"></a>隐式锁</h5><p>当事务进行 <code>Insert</code> 插入记录后，如果其他事务执行了 <a href="#%E9%94%81%E5%AE%9A%E8%AF%BB%EF%BC%88%E5%BD%93%E5%89%8D%E8%AF%BB%EF%BC%89">锁定读（当前读）</a> ，可能会读到当前插入的数据，这是不被允许的，因为会发生脏读（读到未提交的数据），所以在 <code>Insert</code> 插入记录时，会给 <code>Insert</code> 的记录上一个隐式锁，防止其他事务读取，因此其他读取的事务会阻塞住</p><h3 id="一致性读（快照读）"><a href="#一致性读（快照读）" class="headerlink" title="一致性读（快照读）"></a>一致性读（快照读）</h3><p>所有普通的<code>SELECT</code>语句（<code>plain SELECT</code>）在<code>READ COMMITTED</code>、<code>REPEATABLE READ</code>隔离级别下都算是<code>一致性读</code>，比方说：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> t2 <span class="hljs-keyword">ON</span> t1.col1 <span class="hljs-operator">=</span> t2.col2<br></code></pre></td></tr></table></figure><p><code>一致性读</code>并不会对表中的任何记录做<code>加锁</code>操作，其他事务可以自由的对表中的记录做改动。（所以不涉及任何上锁）</p><h3 id="锁定读（当前读）"><a href="#锁定读（当前读）" class="headerlink" title="锁定读（当前读）"></a>锁定读（当前读）</h3><p>那么假设我们有一些场景，比如读取用户的余额，这种强一致性场景下必须要求读到最新的数据，怎么办？这时候 <a href="#%E4%B8%80%E8%87%B4%E6%80%A7%E8%AF%BB%EF%BC%88%E5%BF%AB%E7%85%A7%E8%AF%BB%EF%BC%89">一致性读（快照读）</a> 无法满足需要，因此就有了当前读，即通过上锁读取当前最新的数据</p><ul><li><p>给记录上读锁的当前读</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ... LOCK <span class="hljs-keyword">IN</span> SHARE MODE;<br></code></pre></td></tr></table></figure></li><li><p>给记录上写锁的当前读</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ... <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br></code></pre></td></tr></table></figure></li></ul><p>其余的，只要是涉及对数据进行修改的操作也均是 <strong>当前读</strong></p><ul><li>Update</li><li>Delete</li></ul><h2 id="持久性实现原理"><a href="#持久性实现原理" class="headerlink" title="持久性实现原理"></a>持久性实现原理</h2><p>持久性是指事务一旦提交，它对数据库的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</p><p><strong>InnoDB 通过 redo log 重做日志保证了事务的持久性。</strong></p><p><code>redo log</code> 本质是一种 WAL (Write-Ahead-Log) 预写式日志，也即在修改实际数据前，先去写 <code>redo log</code>，写入成功后才去修改数据，因此只要 <code>redo log</code> 保存下来了，就算数据库崩溃，也能根据 <code>redo log</code> 恢复。</p><p>并且还需要明白的是 <code>redo log</code> 不同于 <a href="#undo%20log">undo log</a> ，<code>redo log</code> 是一种物理日志，记录的是 <strong>某一页，某一个偏移地址，修改成了什么</strong>，是存储引擎提供的特性。MyISAM 就不具备这种用于崩溃恢复的特性。</p><p><strong>redo log 具体原理：</strong></p><ul><li>当数据修改时，会先在 redo log 记录这次操作，然后修改 Buffer Pool 中的数据，</li><li>当事务提交时，会调用 fsync 接口对 redo log 进行刷盘。</li><li>redo log 采用的是 WAL（Write-ahead logging，预写式日志），所有修改先写入日志，再更新到 Buffer Pool 。</li><li>如果 MySQL 宕机，重启时可以读取 redo log 中的数据，对数据库进行恢复，保证了数据不会因 MySQL 宕机而丢失，从而满足了持久性要求。</li></ul><blockquote><p>Buffer Pool 中的脏页不会马上刷盘，而是有一些策略来刷盘，主要也是为了提高写入效率。</p><p>这里其实也涉及到一个点，就是为什么不每修改一个页就直接落盘？这不也能保证持久化吗？</p><ul><li>首先，MySQL 中页大小是 16KB ，但是每次我们修改数据可能就几B，并且可能是改了很多不同的页，这样写入的效率很低，并且还是随机写几乎。但是如果我们存 <code>redo log</code> ，<code>redo log</code> 是纯追加式日志，写入是顺序写，效率提高了很多，而且 <code>redo log</code> 写入后不担心持久化问题，脏页由 Buffer Pool 策略控制写入即可。</li></ul></blockquote><h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><ul><li><p>使用 <a href="#%E4%B8%B4%E9%94%AE%E9%94%81">临键锁</a> 的目的是什么？</p></li><li><p>MySQL 怎么防止幻读？</p></li><li><p>Binlog 和 Redolog的区别？</p></li></ul><h2 id="案例（重要）"><a href="#案例（重要）" class="headerlink" title="案例（重要）"></a>案例（重要）</h2><ul><li><a href="https://time.geekbang.org/column/article/75659">https://time.geekbang.org/column/article/75659</a></li><li><a href="https://time.geekbang.org/column/article/78427">https://time.geekbang.org/column/article/78427</a></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.lixueduan.com/posts/mysql/10-acid/">MySQL教程(十)—MySQL ACID 实现原理 - (lixueduan.com)</a></li><li><a href="https://www.lixueduan.com/posts/mysql/04-cap-lock/">MySQL教程(四)—MySQL 幻读与 InnoDB 间隙锁（Gap Lock） - (lixueduan.com)</a></li><li><a href="https://chanjarster.github.io/post/mysql/gap-lock-next-key-lock/">https://chanjarster.github.io/post/mysql/gap-lock-next-key-lock/</a></li><li><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html">https://tech.meituan.com/2014/08/20/innodb-lock.html</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>#未索引</tag>
      
      <tag>数据库/关系型数据库</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
